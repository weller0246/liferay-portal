@component-name = "portal-staging"
definition {

	property portal.release = "true";
	property portal.upstream = "true";
	property testray.main.component.name = "Export/Import Framework";

	setUp {
		TestCase.setUpPortalInstance();

		User.firstLoginPG();
	}

	tearDown {
		var testPortalInstance = PropsUtil.get("test.portal.instance");

		if ("${testPortalInstance}" == "true") {
			PortalInstances.tearDownCP();
		}
		else {
			User.logoutAndLoginPG(
				userLoginEmailAddress = "test@liferay.com",
				userLoginFullName = "Test Test");

			PagesAdmin.tearDownCP();

			Site.tearDownCP();
		}
	}

	@description = "This is a use case for LPS-123156. Verify if information about staging system settings are present."
	@priority = "3"
	test AssertStagingSystemSettingsInfo {
		property test.name.skip.portal.instance = "ExportImport#AssertSystemSettingsInfo";

		task ("When: User open the Web Content configuration in System settings") {
			SystemSettings.openSystemSettingsAdmin();

			SystemSettings.gotoConfiguration(
				configurationCategory = "Web Content",
				configurationName = "Web Content",
				configurationScope = "Virtual Instance Scope");
		}

		task ("Then: The correct labels will be visible") {
			SystemSettings.viewTextLabel(fieldLabel = "Single Asset Publish Process Includes Version History");

			SystemSettings.viewSettingsText(settingsText = "Specify characters that are not allowed in web content folder names.");

			SystemSettings.openSystemSettingsAdmin();
		}

		task ("And: In the Staging configuration in System settings User can see the correct labels for LAR export / import") {
			SystemSettings.gotoConfiguration(
				configurationCategory = "Infrastructure",
				configurationName = "Staging",
				configurationScope = "Virtual Instance Scope");

			SystemSettings.viewTextLabel(fieldLabel = "Delete temporary LAR during a failed staging publish process.");

			SystemSettings.viewSettingsText(settingsText = "Uncheck to avoid deleting the temporary LAR during a failed staging publish process. In remote staging contexts, this only applies for the staging environment.");

			SystemSettings.viewTextLabel(fieldLabel = "Delete temporary LAR during a successful staging publish process.");

			SystemSettings.viewSettingsText(settingsText = "Uncheck to avoid deleting the temporary LAR during a successful staging publish process. In remote staging contexts, this only applies for the staging environment.");
		}
	}

	@description = "This is a use case for LPS-83011. Verify if a user can configure asset links when export."
	@priority = "4"
	test AssetLinksCanBeConfiguredWhenExport {
		property test.name.skip.portal.instance = "ExportImport#AssetLinksCanBeConfiguredWhenExport";

		task ("Given: User add a new site with 2 WC") {
			JSONGroup.addGroup(groupName = "Site Name");

			for (var count : list "1,2") {
				JSONWebcontent.addWebContent(
					content = "Web Content Content ${count}",
					groupName = "Site Name",
					title = "Web Content Title ${count}");
			}
		}

		task ("And: Add an existing related asset to the first WC") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentNavigator.gotoEditCP(webContentTitle = "Web Content Title 2");

			WebContent.addExistingRelatedAssetCP(
				assetTitle = "Web Content Title 1",
				assetType = "Basic Web Content",
				siteName = "Site Name");
		}

		task ("When: User export the site with unchecking WC") {
			LAR.configureExportSiteCP(
				siteScopeName = "Site Name",
				uncheckContentNameList = "Web Content");

			LAR.clickExportButton();
		}

		task ("Then: The downloaded LAR should not contain the folder related to asset links") {
			var larFileName1 = LAR.getLarFileName();

			LAR.downloadLar();

			AntCommand(
				locator1 = "build-test.xml",
				value1 = "unzip-temp-file -DfileName=${larFileName1}");

			var folderExisted1 = LAR.isExistedFolder(folderName = "com.liferay.asset.kernel.model.adapter.StagedAssetLink");

			if ("${folderExisted1}" == "false") {
				echo("The download temp file doesn't contain the com.liferay.asset.kernel.model.adapter.StagedAssetLink folder.");
			}
			else {
				fail("The download temp file contains the com.liferay.asset.kernel.model.adapter.StagedAssetLink folder.");
			}
		}

		task ("When: User enable 'Include All Asset Links' in System settings, then export the site with unchecking WC") {
			PortalSettings.gotoConfiguration(
				configurationCategory = "Infrastructure",
				configurationName = "Export/Import, Staging",
				configurationScope = "Virtual Instance Scope");

			SystemSettings.configureSystemSetting(
				enableSetting = "true",
				settingFieldName = "Include All Asset Links");

			LAR.configureExportSiteCP(
				siteScopeName = "Site Name",
				uncheckContentNameList = "Web Content");

			LAR.clickExportButton();
		}

		task ("Then: The exported LAR file should contain the folder related to asset links") {
			var larFileName2 = LAR.getLarFileName();

			LAR.downloadLar();

			AntCommand(
				locator1 = "build-test.xml",
				value1 = "unzip-temp-file -DfileName=${larFileName2}");

			var folderExisted2 = LAR.isExistedFolder(folderName = "com.liferay.asset.kernel.model.adapter.StagedAssetLink");

			if ("${folderExisted2}" == "true") {
				echo("The download temp file contain the com.liferay.asset.kernel.model.adapter.StagedAssetLink folder.");
			}
			else {
				fail("The download temp file doesn't contain the com.liferay.asset.kernel.model.adapter.StagedAssetLink folder.");
			}
		}
	}

	@description = "This is a use case for LRQA-73362. Verify if custom fields can be added and deleted through importing their LAR file."
	@priority = "4"
	test CustomFieldDeletionViaImporting {
		property app.server.bundles.size = "1";
		property databases.size = "1";
		property minimum.slave.ram = "24";
		property test.name.skip.portal.instance = "ExportImport#CustomFieldDeletionViaImporting";

		task ("Given: User add an input field for document then export it") {
			CustomFields.addCP(
				customFieldName = "Text Field",
				customFieldType = "Input Field",
				customInputDataType = "Text",
				modelResource = "com.liferay.document.library.kernel.model.DLFileEntry");

			CustomFields.openCustomFieldAdmin();

			LAR.exportPortlet(
				larFileName = "custom_fields.portlet.lar",
				portletName = "Custom Fields");
		}

		task ("When: User import this LAR file to the second portal") {
			User.logoutPG();

			User.firstLoginUI(
				password = "test",
				specificURL = "http://localhost:9080",
				userEmailAddress = "test@liferay.com");

			CustomFields.openCustomFieldAdmin(baseURL = "http://localhost:9080");

			LAR.importPortlet(larFileName = "custom_fields.portlet.lar");
		}

		task ("Then: The input field will be present") {
			CustomFields.viewCPIsPresent(
				customFieldName = "Text Field",
				resourceName = "Document");
		}

		task ("When: User delete the input field on the first portal then export it") {
			User.logoutPG(specificURL = "http://localhost:9080");

			User.loginPG();

			CustomFields.openCustomFieldAdmin();

			CustomFields.deleteCP(
				customFieldName = "Text Field",
				resourceName = "Document");

			CustomFields.openCustomFieldAdmin();

			LAR.exportPortlet(
				exportIndividualDeletions = "true",
				larFileName = "custom_fields_deletion.portlet.lar",
				portletName = "Custom Fields");
		}

		task ("And: Login on the second portal and import this LAR file") {
			User.logoutPG();

			User.firstLoginUI(
				password = "test",
				specificURL = "http://localhost:9080",
				userEmailAddress = "test@liferay.com");

			CustomFields.openCustomFieldAdmin(baseURL = "http://localhost:9080");

			LAR.importPortlet(
				importDeletions = "true",
				larFileName = "custom_fields_deletion.portlet.lar");
		}

		task ("Then: The Input field will not be present anymore") {
			CustomFields.viewCPIsNotPresent(
				customFieldName = "Text Field",
				resourceName = "Document");
		}
	}

	@description = "This is a use case for LPS-125446. Verify if display style remains even after navigation."
	@priority = "4"
	test DisplayStyleCanRemainAfterNavigation {
		task ("Given: User make a successful export") {
			ProductMenu.gotoPortlet(
				category = "Publishing",
				portlet = "Export");

			LexiconEntry.gotoAdd();

			LAR.exportWithAssertionOnSuccess();
		}

		task ("When: User change display style") {
			LexiconEntry.changeDisplayStyle(displayStyle = "table");
		}

		task ("Then: The display style stays the same after accessing the export process page again") {
			ProductMenu.gotoPortlet(
				category = "Publishing",
				portlet = "Export");

			LexiconEntry.viewActiveDisplayStyle(displayStyle = "table");
		}
	}

	@description = "This is a use case for LPS-84223. Verify if a publish fails adding a file entry that do not exist."
	@priority = "3"
	test DLLinkValidationInWebContent {
		task ("Given: User add a new file") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "guest");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentFile = "Document_1.jpg",
				dmDocumentTitle = "DM Document Title");
		}

		task ("And: Save the URL of the document then edit it by adding extra numbers at the end") {
			DMNavigator.gotoDocumentCP(dmDocumentTitle = "DM Document Title");

			DMDocument.expandInfo();

			var dmDocumentURL = selenium.getAttribute("//input[contains(@id,'urlInput')]@value");

			var editDocumentURL = StringUtil.replaceFirst("${dmDocumentURL}", "_1", "_10000");

			echo("## * Edit Document URL: ${editDocumentURL}");

			var entryExternalURL = StringUtil.replace("${editDocumentURL}", "http://", "");

			echo("## * Entry External URL: ${entryExternalURL}");
		}

		task ("When: User try to publish a WC with the previously saved wrong external URL") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			WebContentNavigator.gotoAddCP();

			PortletEntry.inputTitle(title = "Web Content Title");

			CKEditor.addEntryExternalURL(
				displayText = "${editDocumentURL}",
				entryExternalURL = "${entryExternalURL}",
				fieldLabel = "Content");

			Button.clickPublish();
		}

		task ("Then: The publish process fails with corresponding error message") {
			AssertTextPresent(
				locator1 = "Message#ERROR",
				value1 = "Your request failed to complete.");

			AssertTextEquals.assertPartialText(
				locator1 = "Message#ERROR_DISMISSIBLE",
				value1 = "Unable to validate referenced document because it cannot be found with the following parameters");
		}
	}

	@description = "Verify is possible edit an exported template."
	@priority = "4"
	test EditExportTemplate {
		property test.name.skip.portal.instance = "ExportImport#EditExportTemplate";

		task ("Given: User add a new Blog entry and web content") {
			JSONBlog.addEntry(
				entryContent = "Blogs Entry Content",
				entryTitle = "Blogs Entry Title");

			JSONWebcontent.addWebContent(
				content = "Web Content Content",
				groupName = "Guest",
				title = "Web Content Title");
		}

		task ("And: User creates a new Export template which include Web contents but exclude Blogs") {
			LAR.openExportAdmin(siteScopeName = "guest");

			LAR.addExportTemplateCP(
				exportTemplateDescription = "Export Template Description",
				exportTemplateName = "Export Template Name");

			LAR.configureExportOptions(
				checkContentNameList = "Web Content",
				uncheckContentNameList = "Blogs");

			LAR.saveExportTemplateCP(
				exportTemplateDescription = "Export Template Description",
				exportTemplateName = "Export Template Name");
		}

		task ("And: Export the portal based on this template then download it") {
			LAR.exportExportTemplateCP(
				exportTemplateDescription = "Export Template Description",
				exportTemplateName = "Export Template Name",
				larFileName = "Export.Template");

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("And: Import the LAR file including only the web content") {
			JSONGroup.addGroup(groupName = "Site Name");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name");

			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentNavigator.gotoEditCP(webContentTitle = "Web Content Title");

			WebContent.viewCP(
				webContentContent = "Web Content Content",
				webContentTitle = "Web Content Title");
		}

		task ("When: User configures the imported export template to include Blogs too") {
			LAR.openExportAdmin(siteScopeName = "guest");

			LexiconEntry.gotoHeaderMenuItem(menuItem = "Export Templates");

			LAR.editExportTemplateCP(
				exportTemplateDescriptionEdit = "Export Template Description Edit",
				exportTemplateName = "Export Template Name",
				exportTemplateNameEdit = "Export Template Name Edit");

			LAR.configureExportOptions(checkContentNameList = "Blogs");

			LAR.saveExportTemplateCP(
				exportTemplateDescription = "Export Template Description Edit",
				exportTemplateName = "Export Template Name Edit");
		}

		task ("And: Export then download the new LAR file") {
			LAR.exportExportTemplateCP(
				exportTemplateDescription = "Export Template Description Edit",
				exportTemplateName = "Export Template Name Edit",
				larFileName = "Edited Export Template Name");

			var larFileName = LAR.getLarFileName();

			AssertTextEquals(
				locator1 = "ExportImport#CURRENT_AND_PREVIOUS_STATUS_1",
				value1 = "Successful");

			LAR.downloadLar();
		}

		task ("Then: User import the LAR file and can see the imported Blog entry on the site") {
			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name");

			BlogsNavigator.openBlogsAdmin(siteURLKey = "site-name");

			BlogsNavigator.gotoEntryCP(entryTitle = "Blogs Entry Title");

			BlogsEntry.viewEntryCP(
				entryContent = "Blogs Entry Content",
				entryTitle = "Blogs Entry Title");
		}
	}

	@description = "This is a use case for LPS-86501. Verify is possible edit an imported template."
	@priority = "3"
	test EditImportedContentPageViaImportedSiteTemplate {
		property osgi.module.configuration.file.names = "com.liferay.layout.configuration.LayoutExportImportConfiguration.config";
		property osgi.module.configurations = "exportDraftLayout=&quot;true&quot;";
		property testray.component.names = "Training";

		task ("Given: User add a new site template") {
			SiteTemplates.addCP(
				siteTemplateActive = "Yes",
				siteTemplateName = "Site Template Name");
		}

		task ("And: Import a pre-configured fragment collection to the template") {
			LexiconEntry.gotoEntryMenuItem(
				menuItem = "Manage",
				rowEntry = "Site Template Name");

			ProductMenu.gotoPortlet(
				category = "Design",
				portlet = "Fragments");

			FragmentsAdmin.importCollectionFromDependenciesFolder(collectionZipFile = "fragment-collection.zip");
		}

		task ("And: Add new site based on the new site template then a new fragment to it") {
			SiteTemplatesNavigator.openSiteTemplatesAdmin();

			SiteTemplates.addSitePageViaSiteTemplateCP(
				pageName = "Test Template Content Page",
				sitePageType = "Content Page",
				siteTemplateName = "Site Template Name");

			PageEditor.addFragment(
				collectionName = "Collection Name",
				fragmentName = "Content");
		}

		task ("And: Edit the fragment's information") {
			PageEditor.editFragmentText(
				contributed = "false",
				fragmentName = "Content",
				text = "Editing Finished");

			PageEditor.viewFragmentEditableText(
				contributed = "false",
				editableText = "Editing Finished",
				fragmentName = "Content");
		}

		task ("And: Export the site template then delete it") {
			SiteTemplatesNavigator.openSiteTemplatesAdmin();

			LAR.exportPortlet(
				larFileName = "site-template-content-page.lar",
				portletName = "Site Templates");

			SiteTemplatesNavigator.openSiteTemplatesAdmin();

			SiteTemplates.deleteCP(siteTemplateName = "Site Template Name");
		}

		task ("When: User import the exported site template") {
			SiteTemplatesNavigator.openSiteTemplatesAdmin();

			LAR.importPortlet(
				larFileName = "site-template-content-page.lar",
				portletName = "Site Templates");

			SiteTemplates.viewCP(siteTemplateName = "Site Template Name");

			Refresh();
		}

		task ("Then: The imported site template can be edited") {
			LexiconEntry.gotoEntryMenuItem(
				menuItem = "Manage",
				rowEntry = "Site Template Name");

			ProductMenu.gotoPortlet(
				category = "Site Builder",
				portlet = "Pages");

			PagesAdmin.gotoPageEllipsisMenuItem(
				menuItem = "Edit",
				pageName = "Test Template Content Page");

			PageEditor.viewFragmentEditableText(
				contributed = "false",
				editableText = "Editing Finished",
				fragmentName = "Content");

			AssertConsoleTextNotPresent(value1 = "javax.portlet.PortletException:");

			AssertConsoleTextNotPresent(value1 = "org.apache.jasper.JasperException:");

			AssertConsoleTextNotPresent(value1 = "java.lang.NullPointerException");
		}
	}

	@description = "This is a use case for LPS-82752. Verify is possible export content and then publish."
	@priority = "5"
	test ExportContentThenPublish {
		property portal.acceptance = "true";

		task ("Given: User add a new site and enable local staging") {
			JSONGroup.addGroup(groupName = "Site Name");

			JSONStaging.enableLocalStaging(groupName = "Site Name");
		}

		task ("And: Add a new web content on staging then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name-staging");

			WebContentNavigator.gotoAddCP();

			WebContent.addCP(
				webContentContent = "WC WebContent Content",
				webContentTitle = "WC WebContent Title");

			PortletEntry.publish();
		}

		task ("Then: Site can be exported then published") {
			LAR.exportSiteCP(siteScopeName = "Site Name");

			Staging.openStagingAdmin(siteURLKey = "site-name-staging");

			Staging.publishCustomPublication();
		}
	}

	@description = "This is a use case for LPS-95589. Verify is not possible export a DM with deleted document link."
	@priority = "4"
	test ExportDMWithDeletedDocumentLink {
		property test.name.skip.portal.instance = "ExportImport#ExportDMWithDeletedDocumentLink";

		task ("Given: User add a new site with a new document") {
			JSONGroup.addGroup(groupName = "Site Name");

			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "site-name");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentFile = "Document_1.jpg",
				dmDocumentTitle = "DM Document Title");
		}

		task ("And: Add a new a document type") {
			DMNavigator.openDocumentTypesAdmin(siteURLKey = "site-name");

			DMDocumentType.add(
				dmDocumentTypeDescription = "DM Document Type Description",
				dmDocumentTypeFieldNames = "Image",
				dmDocumentTypeName = "DM Document Type Name");

			DMDocumentType.viewCP(dmDocumentTypeName = "DM Document Type Name");
		}

		task ("When: User add a new a document based on the new document type and the previously created document") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "site-name");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentTitle = "DM Type Document Title",
				dmDocumentTypeName = "DM Document Type Name",
				imageField = "DM Document Title",
				imageFileName = "DM Document Title",
				navTab = "Documents and Media");
		}

		task ("And: Delete the first document") {
			JSONDocument.deleteFile(
				dmDocumentTitle = "DM Document Title",
				groupName = "Site Name");
		}

		task ("Then: The export process of the DM admin is successful") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "site-name");

			LAR.exportPortlet(larFileName = "DocumentsandMedia_portlet.lar");

			AssertConsoleTextNotPresent(value1 = "NoSuchFileEntryException");
		}
	}

	@description = "Verify is possible export and import a DDL via Global."
	@priority = "5"
	test ExportImportDDLViaGlobal {
		property test.name.skip.portal.instance = "ExportImport#ExportImportDDLViaGlobal";

		task ("Given: User adds a new site and a page to it") {
			JSONGroup.addGroup(groupName = "Site Name");

			JSONLayout.addPublicLayout(
				groupName = "Site Name",
				layoutName = "Test Page");
		}

		task ("And: Add a new DDL data definition to the global site with a field") {
			PageTemplatesAdmin.openPageTemplatesAdmin(siteURLKey = "global");

			ProductMenu.gotoPortlet(
				category = "Content & Data",
				portlet = "Dynamic Data Lists");

			DDLDataDefinition.addCP(
				ddlDataDefinitionDescription = "DDL Definition Description",
				ddlDataDefinitionName = "DDL Definition");

			DynamicDataMapping.addField(
				field = "Text",
				fieldFieldLabel = "Text Label",
				fieldName = "TextName");

			DDLDataDefinition.save();
		}

		task ("And: Add a new DDL to the global site with chosing the previously created DDL data definition") {
			PageTemplatesAdmin.openPageTemplatesAdmin(siteURLKey = "global");

			ProductMenu.gotoPortlet(
				category = "Content & Data",
				portlet = "Dynamic Data Lists");

			DDLList.addCP(
				ddlListDescription = "DDL List Description",
				ddlListName = "DDL List");

			DDLDataDefinition.selectCP(ddlDataDefinitionName = "DDL Definition");

			DDLDataDefinition.save();
		}

		task ("And: Populate the new DDL data definition's field with text") {
			DDLRecord.addCP(
				ddlDataDefinitionName = "DDL Definition",
				ddlListName = "DDL List");

			DDLRecord.populateFieldText(
				ddlRecordFieldData = "DDL Definition Record",
				field = "Text",
				fieldFieldLabel = "Text Label",
				fieldName = "TextName");

			PortletEntry.publish();
		}

		task ("When: User export the DDL portlet then imports it to the default site") {
			PageTemplatesAdmin.openPageTemplatesAdmin(siteURLKey = "global");

			ProductMenu.gotoPortlet(
				category = "Content & Data",
				portlet = "Dynamic Data Lists");

			LAR.exportPortlet(
				larFileName = "DDL.portlet.lar",
				siteScopeName = "Global");

			Navigator.openSiteURL(siteName = "Site Name");

			ProductMenu.gotoPortlet(
				category = "Content & Data",
				portlet = "Dynamic Data Lists");

			LAR.importPortlet(
				larFileName = "DDL.portlet.lar",
				siteName = "Site Name");
		}

		task ("Then: The populated DDL data definition will be present on the default site") {
			Navigator.openURL();

			Navigator.openSiteURL(siteName = "Site Name");

			ProductMenu.gotoPortlet(
				category = "Content & Data",
				portlet = "Dynamic Data Lists");

			DDLNavigator.gotoListRecords(ddlListName = "DDL List");

			DDLRecord.viewFirstFieldCP(
				ddlRecordFieldData = "DDL Definition Record",
				field = "Text",
				fieldFieldLabel = "Text Label");
		}
	}

	@description = "Verify is possible export import deletions."
	@priority = "4"
	test ExportImportDeletions {
		property test.name.skip.portal.instance = "ExportImport#ExportImportDeletions";

		task ("Given: User adds a new WC then export it") {
			JSONWebcontent.addWebContent(
				content = "Web Content Content",
				groupName = "Guest",
				title = "Web Content Title");

			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			LAR.exportPortlet(larFileName = "ExportWebContent.lar");
		}

		task ("And: Delete the WC then export it") {
			JSONWebcontent.deleteWebContent(
				groupName = "Guest",
				title = "Web Content Title");

			Refresh();

			LAR.exportPortlet(
				exportIndividualDeletions = "true",
				larFileName = "ExportWebContentDeletion.lar");
		}

		task ("When: User imports the first LAR file") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			LAR.importPortlet(larFileName = "ExportWebContent.lar");
		}

		task ("Then: The WC will be present") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			WebContent.viewTitle(webContentTitle = "Web Content Title");
		}

		task ("When: User imports the second LAR file") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			LAR.importPortlet(
				importDeletions = "true",
				larFileName = "ExportWebContentDeletion.lar");
		}

		task ("Then: The WC will be deleted") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			WebContent.viewNotPresentCP(webContentTitle = "Web Content Title");
		}
	}

	@description = "This is a use case for LPS-91735. Verify is possible export/import DDM structure in Global site via instances."
	@priority = "3"
	test ExportImportGlobalDDMStructureViaInstances {
		property portal.release = "false";
		property test.name.skip.portal.instance = "ExportImport#ExportImportGlobalDDMStructureViaInstances";

		task ("Given: User adds a new site, a page to it then export the Site including WC's but excluding DM's") {
			LAR.openExportAdmin(siteScopeName = "Global");

			LexiconEntry.gotoAdd();

			LAR.configureExportOptions(
				checkContentNameList = "Web Content",
				uncheckContentNameList = "Documents and Media");

			AssertClick(
				key_text = "Export",
				locator1 = "Button#ANY",
				value1 = "Export");

			var key_larFileName = "${larFileName}";

			AssertTextEquals(
				locator1 = "ExportImport#CURRENT_AND_PREVIOUS_STATUS_1",
				value1 = "Successful");

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("When: User adds a new virtual instance") {
			ApplicationsMenu.gotoPortlet(
				category = "System",
				panel = "Control Panel",
				portlet = "Virtual Instances");

			PortalInstances.addCP(
				mailDomain = "www.able.com",
				virtualHost = "www.able.com",
				webId = "www.able.com");
		}

		task ("And: Import the exported LAR file") {
			User.firstLoginPG(
				password = "test",
				userEmailAddress = "test@www.able.com",
				virtualHostsURL = "http://www.able.com:8080");

			LAR.importSiteCP(
				baseURL = "http://www.able.com:8080",
				larFileName = "${larFileName}",
				siteName = "Global");
		}

		task ("Then: The import should be successful without error message on console") {
			AssertConsoleTextNotPresent(value1 = "com.liferay.exportimport.kernel.lar.PortletDataException");
		}
	}

	@description = "This is a use case for LPS-91440. Verify is possible export/import Global Pages via instances."
	@priority = "3"
	test ExportImportGlobalPagesViaInstances {
		property portal.release = "false";
		property test.name.skip.portal.instance = "ExportImport#ExportImportGlobalPagesViaInstances";

		task ("Given: User configure the export on Global Site to include Pages but exclude DM's and WC's then export it") {
			LAR.openExportAdmin(siteScopeName = "Global");

			LexiconEntry.gotoAdd();

			LAR.configureExportOptions(
				checkContentNameList = "Pages",
				uncheckContentNameList = "Documents and Media,Web Content");

			AssertClick(
				key_text = "Export",
				locator1 = "Button#ANY",
				value1 = "Export");

			var key_larFileName = "${larFileName}";

			AssertTextEquals(
				locator1 = "ExportImport#CURRENT_AND_PREVIOUS_STATUS_1",
				value1 = "Successful");

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("When: User adds a new virtual instance") {
			ApplicationsMenu.gotoPortlet(
				category = "System",
				panel = "Control Panel",
				portlet = "Virtual Instances");

			PortalInstances.addCP(
				mailDomain = "www.able.com",
				virtualHost = "www.able.com",
				webId = "www.able.com");
		}

		task ("And: Imports the exported LAR file on the new instance") {
			User.logoutPG();

			User.firstLoginPG(
				password = "test",
				userEmailAddress = "test@www.able.com",
				virtualHostsURL = "http://www.able.com:8080");

			LAR.importSiteCP(
				baseURL = "http://www.able.com:8080",
				larFileName = "${larFileName}",
				siteName = "Global");
		}

		task ("Then: The import should be successful without error message on console") {
			AssertConsoleTextNotPresent(value1 = "com.liferay.exportimport.kernel.lar.PortletDataException");
		}
	}

	@description = "This is a use case for LPS-128533. Verify is possible export/import of Journal Article with link to layout."
	@priority = "3"
	test ExportImportJournalArticleWithLinkToPage {
		property testray.component.names = "Web Content Administration";

		task ("Given: User adds a new site and 3 page to it") {
			JSONGroup.addGroup(groupName = "Site A");

			for (var count : list "A,B,C") {
				JSONLayout.addPublicLayout(
					groupName = "Site A",
					layoutName = "Page ${count}");
			}
		}

		task ("And: Add a new WC structure with a field") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-a");

			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "WC Structure Description",
				structureName = "WC Structure Name");

			DataEngine.addField(
				fieldFieldLabel = "Link to Page",
				fieldName = "Link to Page");

			WebContentStructures.saveCP(structureName = "WC Structure Name");
		}

		task ("And: Add a new WC template related to the structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-a");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "WC Structure Name",
				templateDescription = "WC Template Description",
				templateFieldNames = "Link to Page",
				templateName = "WC Template Name");
		}

		task ("And: Add a new WC which is based on the WC template and structure and linked to the second page, then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-a");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentLinkToPage = "Page B",
				webContentTitle = "Web Content Title A");

			PortletEntry.publish();
		}

		task ("And: Add a new WC which is based on the WC template and structure and linked to the first page, then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-a");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentLinkToPage = "Page C",
				webContentTitle = "Web Content Title B");

			PortletEntry.publish();
		}

		task ("And: Add a WCD portlet to the first page and second then add a WC to each WCD") {
			for (var count : list "A,B") {
				JSONLayout.addWidgetToPublicLayout(
					groupName = "Site A",
					layoutName = "Page ${count}",
					widgetName = "Web Content Display");

				Navigator.gotoSitePage(
					pageName = "Page ${count}",
					siteName = "Site A");

				WebContentDisplayPortlet.selectWebContent(webContentTitle = "Web Content Title ${count}");
			}
		}

		task ("When: User exports the site and creates a new site with 3 pages") {
			LAR.exportSiteCP(siteScopeName = "Site A");

			var key_larFileName = "${larFileName}";
			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();

			JSONGroup.addGroup(groupName = "Site B");

			for (var count : list "A,B,C") {
				JSONLayout.addPublicLayout(
					groupName = "Site B",
					layoutName = "Widget ${count}");
			}
		}

		task ("And: Delete the first site then import the LAR file on the new site") {
			JSONGroup.deleteGroupByName(groupName = "Site A");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site B");
		}

		task ("Then: On Site B, the link from WC1 will point to Page B while the link from WC2 will point to Page C") {
			Navigator.gotoSitePage(
				pageName = "Page A",
				siteName = "Site B");

			WebContentDisplayPortlet.viewContent(
				displayText = "Link to Page",
				pageName = "Page B",
				webContentTitle = "Web Content Title A");

			WebContentDisplayPortlet.viewContent(
				displayText = "Link to Page",
				pageName = "Page C",
				webContentTitle = "Web Content Title B");
		}
	}

	@description = "This is a use case for LPS-88378. Verify is possible export/import layout circular reference."
	@priority = "3"
	test ExportImportLayoutCircularReference {
		property testray.component.names = "Site Pages Administration,Web Content Administration";

		task ("Given: User adds a new site and a page to it") {
			JSONGroup.addGroup(groupName = "Site Name");

			JSONLayout.addPublicLayout(
				groupName = "Site Name",
				layoutName = "Site Page");
		}

		task ("And: Add child page to the first page then a child page to this page") {
			JSONLayout.addPublicLayout(
				groupName = "Site Name",
				layoutName = "Site Child Page",
				parentLayoutName = "Site Page");

			JSONLayout.addPublicLayout(
				groupName = "Site Name",
				layoutName = "Site Child Child Page",
				parentLayoutName = "Site Child Page");
		}

		task ("And: Add new WC structure with a field") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "WC Structure Description",
				structureName = "WC Structure Name");

			DataEngine.addField(
				fieldFieldLabel = "Link to Page",
				fieldName = "Link to Page");

			WebContentStructures.saveCP(structureName = "WC Structure Name");
		}

		task ("And: Add a new WC template related to the new structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "WC Structure Name",
				templateDescription = "WC Template Description",
				templateFieldNames = "Link to Page",
				templateName = "WC Template Name");
		}

		task ("And: Add a new WC based on the new structure and template and linked to the first child page then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentLinkToPage = "Site Child Page",
				webContentTitle = "WC WebContent Title 1");

			PortletEntry.publish();
		}

		task ("And: Add a second WC based on the new structure and template and linked to the child page of the child page then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentLinkToPage = "Site Child Child Page",
				webContentTitle = "WC WebContent Title 2");

			PortletEntry.publish();
		}

		task ("When: User adds a WCD portlet to the site and select the second WC to it") {
			JSONLayout.addWidgetToPublicLayout(
				groupName = "Site Name",
				layoutName = "Site Page",
				widgetName = "Web Content Display");

			Navigator.gotoSitePage(
				pageName = "Site Page",
				siteName = "Site Name");

			WebContentDisplayPortlet.selectWebContent(webContentTitle = "WC WebContent Title 2");

			WebContentDisplayPortlet.viewContent(
				displayText = "Link to Page",
				pageName = "Site Child Child Page",
				webContentTitle = "WC WebContent Title 2");
		}

		task ("And: Exports the site") {
			LAR.exportSiteCP(siteScopeName = "Site Name");

			var key_larFileName = "${larFileName}";

			AssertTextEquals(
				locator1 = "ExportImport#CURRENT_AND_PREVIOUS_STATUS_1",
				value1 = "Successful");

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("Then: User can import the LAR file on a new site without error on the console") {
			JSONGroup.addGroup(groupName = "Site Name B");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name B");

			AssertConsoleTextNotPresent(value1 = "java.lang.NullPointerException");
		}
	}

	@description = "Verify is possible export/import a Portlet."
	@priority = "5"
	test ExportImportPortlet {
		property portal.acceptance = "true";

		task ("Given: User adds a new page with an IFrame portlet") {
			JSONLayout.addPublicLayout(
				groupName = "Guest",
				layoutName = "Test Page Name");

			Navigator.gotoPage(pageName = "Test Page Name");

			Portlet.addPG(portletName = "IFrame");
		}

		task ("And: Configure a custom look for the portlet") {
			Portlet.gotoPortletOptions(
				portletName = "IFrame",
				portletOption = "Look and Feel Configuration");

			IFrame.selectConfigurationFrame();

			Portlet.configureGeneralViaLookAndFeelPG(customTitle = "IFrame Custom");

			IFrame.closeFrame();
		}

		task ("When: User exports the portlet then create a new site with a page") {
			LAR.exportPortlet(larFileName = "IFrame.lar");

			JSONGroup.addGroup(groupName = "Test Site Name");

			JSONLayout.addPublicLayout(
				groupName = "Test Site Name",
				layoutName = "Test Site Page");
		}

		task ("And: User can create an IFrame portlet, then import the LAR file") {
			Navigator.gotoSitePage(
				pageName = "Test Site Page",
				siteName = "Test Site Name");

			Portlet.addPG(portletName = "IFrame");

			LAR.importPortlet(larFileName = "IFrame.lar");
		}

		task ("Then: The custom settings of the portlet is visible") {
			Navigator.gotoSitePage(
				pageName = "Test Site Page",
				siteName = "Test Site Name");

			Portlet.viewTitle(portletName = "IFrame Custom");
		}
	}

	@description = "Verify is possible export/import a Portlet with ADT."
	@priority = "3"
	test ExportImportPortletWithADT {
		task ("Given: User adds a Blog ADT template then a new page") {
			ApplicationDisplayTemplates.openWidgetTemplatesAdmin(siteURLKey = "guest");

			ApplicationDisplayTemplates.addCP(
				adtFile = "adt_blogs_basic.ftl",
				adtType = "Blogs");

			JSONLayout.addPublicLayout(
				groupName = "Guest",
				layoutName = "Test Page Name");
		}

		task ("And: Add a new blog widget to the new page") {
			JSONLayout.addWidgetToPublicLayout(
				groupName = "Guest",
				layoutName = "Test Page Name",
				widgetName = "Blogs");

			JSONBlog.addEntry(
				entryContent = "Blogs Entry Content",
				entryTitle = "Blogs Entry Title");
		}

		task ("And: Configure the ADT template for the blog portlet") {
			Navigator.gotoPage(pageName = "Test Page Name");

			ApplicationDisplayTemplates.selectPortletADT(
				portletName = "Blogs",
				templateName = "Blogs Test ADT");

			Navigator.gotoPage(pageName = "Test Page Name");

			var key_entryTitle = "Blogs Entry Title";

			AssertElementNotPresent(locator1 = "Link#EDIT");

			AssertElementNotPresent(locator1 = "Link#MOVE_TO_RECYCLING_BIN");
		}

		task ("When: User exports the site then adds a new site") {
			LAR.configureExportSiteCP(siteScopeName = "Guest");

			LAR.exportWithAssertionOnSuccess();

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();

			JSONGroup.addGroup(groupName = "Site Name");
		}

		task ("And: Import the LAR file on the new site") {
			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name");
		}

		task ("Then: The blog widget with the ADT template will be visible on the imported page") {
			Navigator.gotoSitePage(
				pageName = "Test Page Name",
				siteName = "Site Name");

			var key_entryTitle = "Blogs Entry Title";

			AssertElementNotPresent(locator1 = "Link#EDIT");

			AssertElementNotPresent(locator1 = "Link#MOVE_TO_RECYCLING_BIN");
		}
	}

	@description = "Verify is possible export/import a Private Page."
	@priority = "5"
	test ExportImportPrivatePage {
		property portal.acceptance = "true";
		property release.feature.flags.disable.DISABLE_PRIVATE_LAYOUTS = "true";
		property testray.component.names = "Training";

		task ("Given: User adds a new private page") {
			Navigator.openURL();

			ProductMenu.gotoPortlet(
				category = "Site Builder",
				portlet = "Pages");

			PagesAdmin.addPrivatePage(pageName = "Private Page");
		}

		task ("When: User export the private page and add a new site") {
			Navigator.gotoPrivateSitePage(
				pageName = "Private Page",
				siteName = "Guest");

			LAR.exportSiteCP(
				larFileName = "ExportPrivatePage",
				privateLayout = "true",
				siteScopeName = "Guest");

			var key_larFileName = "${larFileName}";
			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();

			JSONGroup.addGroup(groupName = "Site Name");
		}

		task ("Then: User can import the private page on the new site") {
			LAR.importSiteCP(
				larFileName = "${larFileName}",
				privateLayout = "true",
				siteName = "Site Name");

			Navigator.gotoPrivateSitePage(
				pageName = "Private Page",
				siteName = "Site Name");
		}
	}

	@description = "This is a use case for LPS-84201. Verify if asset publisher's scope settings can be export/import."
	@priority = "3"
	test ExportImportSiteWithAssetPublisherScopeSetting {
		task ("Given: User adds a new site with a page, then adds an AP widget to it") {
			JSONGroup.addGroup(groupName = "Site Name A");

			JSONLayout.addPublicLayout(
				groupName = "Site Name A",
				layoutName = "Asset Publisher Page");

			JSONLayout.addWidgetToPublicLayout(
				groupName = "Site Name A",
				layoutName = "Asset Publisher Page",
				widgetName = "Asset Publisher");
		}

		task ("And: Adds a second site") {
			JSONGroup.addGroup(groupName = "Site Name B");
		}

		task ("And: Configures the scope of the AP widget on the first site toward the second site") {
			Navigator.gotoSitePage(
				pageName = "Asset Publisher Page",
				siteName = "Site Name A");

			AssetPublisherPortlet.configureScope(otherSite = "Site Name B");
		}

		task ("And: Removes the first site from the scope of the same AP widget") {
			Navigator.gotoSitePage(
				pageName = "Asset Publisher Page",
				siteName = "Site Name A");

			AssetPublisherPortlet.removeSiteScope(removeSiteScopes = "Site Name A");
		}

		task ("When: User exports the first site then deletes the previously created sites") {
			LAR.exportSiteCP(siteScopeName = "Site Name A");

			var key_larFileName = "${larFileName}";

			AssertTextEquals(
				locator1 = "ExportImport#CURRENT_AND_PREVIOUS_STATUS_1",
				value1 = "Successful");

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();

			JSONGroup.deleteGroupByName(groupName = "Site Name A");

			JSONGroup.deleteGroupByName(groupName = "Site Name B");
		}

		task ("And: Adds the deleted sites again with the same name then import the exported LAR file") {
			JSONGroup.addGroup(groupName = "Site Name A");

			JSONGroup.addGroup(groupName = "Site Name B");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name A");
		}

		task ("Then: User can navigate to the imported page of the first site and see the previously configured scope of the AP widget towards the second site") {
			Navigator.gotoSitePage(
				pageName = "Asset Publisher Page",
				siteName = "Site Name A");

			AssetPublisherPortlet.viewConfigureSiteScope(siteName = "Site Name B");
		}
	}

	@description = "This is a use case for LPS-142076. Verify is possible import site with the 'Copy as new' option in the Update data section."
	@priority = "3"
	test ExportImportSiteWithCopyAsNew {
		task ("Add a new site and add a widget page to site") {
			JSONGroup.addGroup(groupName = "Test Site Name");

			JSONLayout.addPublicLayout(
				groupName = "Test Site Name",
				layoutName = "Test Site Name");
		}

		task ("Add a Web Content Display widget to new page") {
			JSONLayout.addWidgetToPublicLayout(
				groupName = "Test Site Name",
				layoutName = "Test Site Name",
				widgetName = "Web Content Display");
		}

		task ("Add a web content with a link as content") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "test-site-name");

			WebContentNavigator.gotoAddCP();

			WebContent.addCP(webContentTitle = "WC WebContent 1");

			CKEditor.addSourceContent(content = '''
<p>Test: <a href="/web/test-site-name/test-site-name">Link</a></p>
''');

			PortletEntry.publish();
		}

		task ("Add the second web content") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "test-site-name");

			WebContentNavigator.gotoAddCP();

			WebContent.addCP(
				webContentContent = "WC WebContent Content",
				webContentTitle = "WC WebContent 2");

			PortletEntry.publish();
		}

		task ("Select display the second Web Content article in WCD") {
			Navigator.gotoSitePage(
				pageName = "Test Site Name",
				siteName = "Test Site Name");

			WebContentDisplayPortlet.selectWebContent(webContentTitle = "WC WebContent 2");
		}

		task ("Export the site") {
			LAR.openExportAdmin(siteScopeName = "test-site-name");

			LexiconEntry.gotoAdd();

			LAR.exportWithAssertionOnSuccess();

			LAR.downloadLar();
		}

		task ("Add a new site based on Blank Site") {
			JSONGroup.addGroup(groupName = "Site Name");
		}

		task ("Import the lar into the new site") {
			var larFileName = LAR.getLarFileName();

			LAR.importSiteCP(
				copyAsNew = "true",
				larFileName = "${larFileName}",
				siteName = "Site Name");
		}

		task ("Assert the console no errors occur") {
			AssertConsoleTextNotPresent(value1 = "Could not execute JDBC batch update");
		}
	}

	@description = "This is a use case for LPS-88331. Verify is possbile export/import a site with nested upload field."
	@priority = "3"
	test ExportImportSiteWithNestedUploadField {
		task ("Given: User adds a new site and a file to it") {
			JSONGroup.addGroup(groupName = "Site A");

			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "site-a");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentFile = "Document_1.jpg",
				dmDocumentTitle = "DM Document Title");
		}

		task ("And: Add new WC structure with a field and a nested field") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-a");

			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "WC Structure Description",
				structureName = "WC Structure Name");

			DataEngine.addField(
				fieldFieldLabel = "Text",
				fieldName = "Text");

			DataEngine.addFieldNested(
				fieldFieldLabel = "Image",
				fieldName = "Image",
				targetFieldLabel = "Text");

			WebContentStructures.saveCP(structureName = "WC Structure Name");
		}

		task ("And: Add a new WC template related to the WC structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-a");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "WC Structure Name",
				templateDescription = "WC Template Description",
				templateFieldNames = "Text,Image",
				templateName = "WC Template Name");
		}

		task ("And: Add a new WC based on the WC template and structure then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-a");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				imageFileName = "DM Document Title",
				navTab = "Documents and Media",
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentImage = "DM Document Title",
				webContentText = "Web Content Text",
				webContentTitle = "Web Content Title");

			PortletEntry.publish();

			WebContent.viewTitle(webContentTitle = "Web Content Title");
		}

		task ("When: User exports the site then delete it") {
			LAR.exportSiteCP(siteScopeName = "Site A");

			var key_larFileName = "${larFileName}";
			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();

			JSONGroup.deleteGroupByName(groupName = "Site A");
		}

		task ("And: Add a new site then import the exported LAR file there") {
			JSONGroup.addGroup(groupName = "Site B");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site B");
		}

		task ("Then: The created file will be present in web content editor after import without error on console") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-b");

			WebContent.viewWithStructureCP(
				webContentImage = "DM Document Title",
				webContentText = "Web Content Text",
				webContentTitle = "Web Content Title");

			AssertConsoleTextNotPresent(value1 = "com.liferay.portal.kernel.repository.InvalidRepositoryIdException");
		}
	}

	@description = "Verify is possible export/import a Smoke template."
	@priority = "5"
	test ExportImportSmoke {
		property portal.acceptance = "true";
		property testray.component.names = "Training";

		task ("Given: User exports default site") {
			LAR.exportSiteCP(siteScopeName = "Guest");

			var key_larFileName = "${larFileName}";
			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("When: Adds a new site then import the LAR file") {
			JSONGroup.addGroup(groupName = "Site Name");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name");
		}

		task ("Then: Import should be successful without error message on console") {
			AssertConsoleTextNotPresent(value1 = "java.lang.StringIndexOutOfBoundsException");

			AssertConsoleTextNotPresent(value1 = "java.lang.NullPointerException");
		}
	}

	@description = "Verify is possible export/import theme settings."
	@priority = "4"
	test ExportImportThemeSettings {
		task ("Given: User adds a new site with a page") {
			JSONGroup.addGroup(groupName = "Site Name");

			PagesAdmin.openPagesAdmin(siteURLKey = "Site Name");

			PagesAdmin.addPage(pageName = "Test Page");

			PagesAdmin.openPagesAdmin(siteURLKey = "Site Name");
		}

		task ("And: Configure custom theme settings for the new page") {
			PagesAdmin.gotoPageEllipsisMenuItem(
				menuItem = "Configure",
				pageName = "Test Page");

			Navigator.gotoNavTab(navTab = "Look and Feel");

			Theme.configureLookAndFeelSpecificLook();

			Theme.configureLookAndFeelShowHeaderSearch(showHeaderSearch = "false");

			Theme.configureLookAndFeelShowMaxMinAppLinks(showMaxMinAppLinks = "true");

			PortletEntry.save();
		}

		task ("When: User configure site export to exclude site page and template settings then publish it") {
			LAR.configureExportSiteCP(
				siteScopeName = "Site Name",
				uncheckLogo = "true",
				uncheckSitePagesSettings = "true",
				uncheckSiteTemplateSettings = "true");

			AssertClick(
				key_text = "Export",
				locator1 = "Button#ANY",
				value1 = "Export");

			AssertTextEquals(
				locator1 = "ExportImport#CURRENT_AND_PREVIOUS_STATUS_1",
				value1 = "Successful");

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("And: Create a new site then import the LAR file") {
			JSONGroup.addGroup(groupName = "Site Name 2");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name 2");
		}

		task ("Then: The custom theme settings of the page has been configured from the LAR file") {
			Navigator.gotoSitePage(
				pageName = "Test Page",
				siteName = "Site Name 2");

			PagesAdmin.viewWidgetPageCurrentTheme(
				checkThemeSettingList = "Show Maximize/Minimize Application Links",
				pageName = "Test Page",
				uncheckThemeSettingList = "Show Header Search");
		}
	}

	@description = "Verify is possible export/import validation."
	@priority = "5"
	test ExportImportValidation {
		property portal.acceptance = "true";
		property test.name.skip.portal.instance = "ExportImport#ExportImportValidation";
		property testray.component.names = "Training";

		task ("Given: User adds a new file and a blog entry") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "guest");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentFile = "Document_1.jpg",
				dmDocumentTitle = "DM Document Title");

			JSONBlog.addEntry(
				entryContent = "Blogs Entry Content",
				entryTitle = "Blogs Entry Title");
		}

		task ("And: Edit the created Blog entry to contain external link to the new file") {
			BlogsNavigator.openBlogsAdmin(siteURLKey = "guest");

			BlogsNavigator.gotoEditCP(entryTitle = "Blogs Entry Title");

			BlogsEntry.addEntryExternalLinkViaBrowseButton(
				imageFileName = "DM Document Title",
				navTab = "Documents and Media");
		}

		task ("When: Export the site which includes blogs but exclude DM and its referenced contents") {
			LAR.configureExportSiteCP(
				checkContentNameList = "Blogs",
				mainContent = "Blogs",
				siteScopeName = "Guest",
				uncheckContentNameList = "Documents and Media",
				uncheckSubContent = "Referenced Content");

			LAR.exportWithAssertionOnSuccess();

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("And: Delete the DM file then add a new site") {
			JSONDocument.deleteFile(
				dmDocumentTitle = "DM Document Title",
				groupName = "Guest");

			JSONGroup.addGroup(groupName = "Site Name");
		}

		task ("Then: User can import the LAR file on this new site and it will not include the previously created DM") {
			LAR.importSiteCP(
				importValidationMissingItem = "DM Document Title",
				larFileName = "${larFileName}",
				siteName = "Site Name");
		}
	}

	@description = "This is a use case for LPS-88743. Verify is possible export/import Web Content circular reference."
	@priority = "3"
	test ExportImportWebContentCircularReference {
		task ("Given: User adds a new site") {
			JSONGroup.addGroup(groupName = "Site Name");
		}

		task ("And: Add a new WC structure with a web content field") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "WC Structure Description",
				structureName = "WC Structure Name");

			DataEngine.addField(
				fieldFieldLabel = "Web Content",
				fieldName = "Web Content");

			WebContentStructures.saveCP(structureName = "WC Structure Name");
		}

		task ("And: Add a new WC template related to the WC structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "WC Structure Name",
				templateDescription = "WC Template Description",
				templateFieldNames = "Web Content",
				templateName = "WC Template Name");

			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");
		}

		task ("And: Add a new WC based on the WC template and structure then publish it") {
			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentTitle = "WC WebContent Title 1");

			PortletEntry.publish();
		}

		task ("And: Add a second WC based on the WC template and structure, pointing to the first WC then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentTitle = "WC WebContent Title 2",
				webContentWebContent = "WC WebContent Title 1");

			PortletEntry.publish();
		}

		task ("When: User edit the first WC then export the site") {
			WebContentNavigator.gotoEditCP(webContentTitle = "WC WebContent Title 1");

			WebContent.editCP(
				webContentTitle = "WC WebContent Title 1",
				webContentTitleEdit = "WC WebContent Title 1",
				webContentWebContent = "WC WebContent Title 2");

			LAR.exportSiteCP(siteScopeName = "Site Name");

			var key_larFileName = "${larFileName}";
			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("And: Delete the site and create a new one") {
			JSONGroup.deleteGroupByName(groupName = "Site Name");

			JSONGroup.addGroup(groupName = "Site Name A");
		}

		task ("And: Import the LAR file on this site") {
			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name A");
		}

		task ("Then: The import should be successful without error message on console") {
			AssertConsoleTextNotPresent(value1 = "com.liferay.journal.exception.NoSuchArticleException");
		}
	}

	@description = "This is a use case for LPS-83326 and LPS-99287. Verify is possible export/import Web Content Folder with a Workflow."
	@priority = "5"
	test ExportImportWebContentFolderWithWorkflow {
		property portal.acceptance = "true";

		task ("Given: User adds a new WC folder with default workflow") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			WebContentFolder.addCP(
				folderDescription = "WC Folder Description",
				folderName = "WC Folder Name");

			WebContentFolder.configureWorkflowCP(
				folderName = "WC Folder Name",
				workflowDefinition = "Single Approver",
				workflowRestriction = "Default Workflow");
		}

		task ("And: Export the web content portlet then delete the wc folder") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			LAR.exportPortlet(larFileName = "WebContent_portlet.lar");

			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			WebContentFolder.moveToRecycleBinCP(folderName = "WC Folder Name");

			RecycleBin.openRecycleBinAdmin(siteURLKey = "guest");

			RecycleBin.emptyCP();
		}

		task ("When: User adds a new site and import the LAR file") {
			JSONGroup.addGroup(groupName = "Site Name");

			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			LAR.importPortlet(larFileName = "WebContent_portlet.lar");
		}

		task ("Then: The WC folder with default workflow has been imported without error on the console") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentFolder.viewFolderWorkflow(
				folderName = "WC Folder Name",
				workflowResourceValue = "Single Approver");

			AssertConsoleTextNotPresent(value1 = "com.liferay.exportimport.kernel.lar.PortletDataException");
		}
	}

	@description = "This is a use case for LPS-86608. Verify is possible export/import Web Content with repeat field."
	@priority = "3"
	test ExportImportWebcontentWithRepeatField {
		task ("Given: User adds a new site") {
			JSONGroup.addGroup(groupName = "Exported Site");

			WebContentNavigator.openWebContentAdmin(siteURLKey = "exported-site");
		}

		task ("And: Add a new WC structure with a field and a nested field which can be repeatable") {
			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "Exported Structure Description",
				structureName = "Exported Structure");

			DataEngine.addField(
				fieldFieldLabel = "Separator",
				fieldName = "Separator");

			DataEngine.addFieldNested(
				fieldFieldLabel = "Text",
				fieldName = "Text",
				targetFieldLabel = "Separator");

			DataEngine.toggleFieldRepeatable(fieldsGroupLabel = "Fields Group");

			WebContentStructures.saveCP(structureName = "Exported Structure");
		}

		task ("And: Add a new WC template related to the structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "exported-site");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "Exported Structure",
				templateDescription = "Exported Template Description",
				templateFieldNames = "Text",
				templateName = "Exported Template");
		}

		task ("And: Add a new WC based on the template and structure, duplicate the duplicable field and fill out the repeated fields") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "exported-site");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "Exported Structure");

			WebContent.addWithStructureCP(
				structureName = "Exported Structure",
				webContentText = "Exported Template",
				webContentTitle = "Exported Article");

			Click(locator1 = "FormFields#FIELD_ADD_DUPLICATE");

			takeScreenshot();

			Type(
				key_fieldFieldLabel = "Text",
				locator1 = "WCEditWebContent#TEXT_INPUT",
				value1 = "Liferay");

			Type(
				index = "2",
				key_fieldFieldLabel = "Text",
				locator1 = "WCEditWebContent#ANY_TEXT_INPUT",
				value1 = "Liferay 1");

			PortletEntry.publish();

			WebContent.viewTitle(webContentTitle = "Exported Article");
		}

		task ("When: User export the web content portlet and add a new site") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "exported-site");

			LAR.exportPortlet(larFileName = "WebContent_portlet.lar");

			JSONGroup.addGroup(groupName = "Imported Site");
		}

		task ("And: Import the LAR file") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "imported-site");

			LAR.importPortlet(larFileName = "WebContent_portlet.lar");
		}

		task ("Then: The WC will be present with the repeated fields") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "imported-site");

			WebContent.viewWithStructureCP(webContentTitle = "Exported Article");

			AssertTextEquals.assertValue(
				key_fieldFieldLabel = "Text",
				locator1 = "WCEditWebContent#TEXT_INPUT",
				value1 = "Liferay");

			AssertTextEquals.assertValue(
				index = "2",
				key_fieldFieldLabel = "Text",
				locator1 = "WCEditWebContent#ANY_TEXT_INPUT",
				value1 = "Liferay 1");
		}

		task ("And: The WC structure will be present") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "imported-site");

			NavItem.gotoStructures();

			WebContentStructures.viewCP(
				structureDescription = "Exported Structure Description",
				structureName = "Exported Structure");

			LexiconEntry.gotoEntry(rowEntry = "Exported Structure");

			AssertVisible(
				key_fieldFieldLabel = "Separator",
				locator1 = "DDMField#SEPARATOR");

			AssertVisible(
				key_fieldFieldLabel = "Text",
				locator1 = "WCEditWebContent#TEXT_INPUT");
		}

		task ("And: The WC template will be present too") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "imported-site");

			NavItem.gotoTemplates();

			WebContentTemplates.viewCP(
				structureName = "Exported Structure",
				templateDescription = "Exported Template Description",
				templateName = "Exported Template");
		}
	}

	@description = "Verify is possible export/import with an export template."
	@priority = "4"
	test ExportImportWithExportTemplate {
		property test.name.skip.portal.instance = "ExportImport#ExportImportWithExportTemplate";

		task ("Given: User adds a new export template") {
			LAR.openExportAdmin(siteScopeName = "Guest");

			LAR.addExportTemplateCP(
				exportTemplateDescription = "Export Template Description",
				exportTemplateName = "Export Template Name");

			LAR.saveExportTemplateCP(
				exportTemplateDescription = "Export Template Description",
				exportTemplateName = "Export Template Name");

			LAR.viewExportTemplateCP(
				exportTemplateDescription = "Export Template Description",
				exportTemplateName = "Export Template Name");
		}

		task ("When: User export the site based on the site template then create a new site") {
			LAR.exportExportTemplateCP(
				exportTemplateDescription = "Export Template Description",
				exportTemplateName = "Export Template Name");

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("Then: The exported site can be imported on the new site") {
			JSONGroup.addGroup(groupName = "Site Name");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name");
		}
	}

	@description = "This is a use case for LPS-88498. Verify if a Guest is able to export files."
	@priority = "5"
	test ExportViaGuest {
		property portal.acceptance = "true";
		property test.name.skip.portal.instance = "ExportImport#ExportViaGuest";

		task ("Given: Add a new user") {
			JSONUser.addUser(
				userEmailAddress = "userea@liferay.com",
				userFirstName = "userfn",
				userLastName = "userln",
				userScreenName = "usersn");

			ApplicationsMenu.gotoPortlet(
				category = "Users",
				panel = "Control Panel",
				portlet = "Users and Organizations");

			User.editPasswordCP(
				userEmailAddress = "userea@liferay.com",
				userScreenName = "usersn");
		}

		task ("When: Default site is exported and the download URL is hit by the new guest user") {
			LAR.exportSiteCP(siteScopeName = "Guest");

			var downloadURL = selenium.getAttribute("//dl/dd/div/h2/span/a@href");

			User.logoutAndLoginPG(
				userLoginEmailAddress = "userea@liferay.com",
				userLoginFullName = "userfn userln");

			Navigator.openSpecificURL(url = "${downloadURL}");
		}

		task ("Then: The download is forbidden because guest role has no sufficient permission") {
			AssertTextEquals(
				locator1 = "Home#ERROR_MESSAGE_ALERT_ERROR",
				value1 = "Forbidden");
		}
	}

	@description = "This is a use case for LPS-88831, LPS-88889 and LPS-88890. Verify is possible export a web content with deleted reference."
	@priority = "4"
	test ExportWebContentWithDeletedReference {
		property test.name.skip.portal.instance = "ExportImport#ExportWebContentWithDeletedReference";

		task ("Given: User adds a new site with a page") {
			JSONGroup.addGroup(groupName = "Site Name");

			JSONLayout.addPublicLayout(
				groupName = "Site Name",
				layoutName = "Test Page");
		}

		task ("And: Add a new file on this site") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "site-name");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentFile = "Document_1.jpg",
				dmDocumentTitle = "DM Document Title");
		}

		task ("And: Add a new WC structure with 2 fields") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "WC Structure Description",
				structureName = "WC Structure Name");

			DataEngine.addFields(fieldNameList = "Link to Page,Image");

			WebContentStructures.saveCP(structureName = "WC Structure Name");
		}

		task ("And: Add a new WC template connected to the WC structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "WC Structure Name",
				templateDescription = "WC Template Description",
				templateFieldNames = "Link to Page,Image",
				templateName = "WC Template Name");
		}

		task ("And: Add a new WC based on the template and structure then publish it") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "WC Structure Name");

			WebContent.addWithStructureCP(
				imageFileName = "DM Document Title",
				navTab = "Documents and Media",
				structureName = "WC Structure Name",
				templateName = "WC Template Name",
				webContentImage = "DM Document Title",
				webContentLinkToPage = "Test Page",
				webContentTitle = "WC WebContent Title");

			PortletEntry.publish();

			WebContent.viewTitle(webContentTitle = "WC WebContent Title");
		}

		task ("When: User deletes the file and the test page, then export the web content") {
			JSONDocument.deleteFile(
				dmDocumentTitle = "DM Document Title",
				groupName = "Site Name");

			JSONLayout.deletePublicLayout(
				groupName = "Site Name",
				layoutName = "Test Page");

			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			LAR.exportPortlet(larFileName = "WebContent_portlet.lar");
		}

		task ("Then: The export of the WC with deleted reference is successful without error on the console") {
			AssertConsoleTextNotPresent(value1 = "com.liferay.exportimport.kernel.lar.PortletDataException");
		}
	}

	@description = "Verify is possible import corrupted file."
	@priority = "5"
	test ImportCorruptedFile {
		property portal.acceptance = "true";

		task ("When: User tries to import corrupted LAR file in Bookmarks") {
			Navigator.openURL();

			ProductMenu.gotoPortlet(
				category = "Content & Data",
				portlet = "Bookmarks");

			AssertTextEquals(
				locator1 = "Portlet#HEADER",
				value1 = "Bookmarks");
		}

		task ("Then: Import process should fail") {
			LAR.importPortlet(
				cannotImport = "true",
				larFileName = "bookmarks-corrupted.portlet.lar",
				uploadFrom = "dependencies");
		}
	}

	@description = "This is a use case for LPS-135706. Verify that exporting and importing a Documents & Media URL does not append UUID to the imported URL if it was not there to begin with."
	@priority = "3"
	test ImportDMUrlWithoutUUID {
		task ("Given: User adds a new file and saves its external URL") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "guest");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentFile = "Document_1.jpg",
				dmDocumentTitle = "DM Document Title");

			DMNavigator.gotoDocumentCP(dmDocumentTitle = "DM Document Title");

			DMDocument.expandInfo();

			var dmDocumentURL = selenium.getAttribute("//input[contains(@id,'urlInput')]@value");

			var editDocumentURL = StringUtil.extractFirst("${dmDocumentURL}", "jpg");
		}

		task ("And: Create a new WC with the saved URL as reference in the source content") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			WebContentNavigator.gotoAddCP();

			PortletEntry.inputTitle(title = "Web Content Title");

			CKEditor.addSourceContent(content = '''<a href="${editDocumentURL}jpg">Link to Document</a>''');

			PortletEntry.publish();
		}

		task ("When: User export with default settings") {
			ProductMenu.gotoPortlet(
				category = "Publishing",
				portlet = "Export");

			LexiconEntry.gotoAdd();

			LAR.exportWithAssertionOnSuccess();

			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("And: Import the LAR file on a freshly created site") {
			JSONGroup.addGroup(groupName = "Site Name");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name");
		}

		task ("Then: The imported WC should have the same source content as when it was created, without the UUID in the pasted URL") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name");

			WebContentNavigator.gotoEditCP(webContentTitle = "Web Content Title");

			CKEditor.assertSourceContent();
		}
	}

	@description = "This is a use case for LPS-84290. Verify is possible export Home Folder Permissions."
	@priority = "3"
	test ImportSiteHomeFolderPermissions {
		task ("Given: User adds a new site") {
			JSONGroup.addGroup(groupName = "Site Name");
		}

		task ("When: User removes the Home Folder permissions from DM portlet for site member role on default site") {
			Navigator.openURL();

			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "guest");

			Portlet.gotoPortletOptions(portletOption = "Home Folder Permissions");

			SelectFrameTop();

			IFrame.selectModalFrame();

			Role.removePermissionPG(
				permissionDefinitionKey = "CONFIGURATION_PERMISSIONS_ADD_SHORTCUT_CHECKBOX",
				roleTitle = "Site Member");

			Role.removePermissionPG(
				permissionDefinitionKey = "CONFIGURATION_PERMISSIONS_ADD_DOCUMENT_CHECKBOX",
				roleTitle = "Site Member");

			Role.removePermissionPG(
				permissionDefinitionKey = "CONFIGURATION_PERMISSIONS_SUBSCRIBE_CHECKBOX",
				roleTitle = "Site Member");

			Role.removePermissionPG(
				permissionDefinitionKey = "CONFIGURATION_PERMISSIONS_VIEW_CHECKBOX",
				roleTitle = "Site Member");

			Role.removePermissionPG(
				permissionDefinitionKey = "CONFIGURATION_PERMISSIONS_ADD_FOLDER",
				roleTitle = "Site Member");
		}

		task ("And: Exports the LAR file of Documents and Media admin page") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "guest");

			Refresh();

			LAR.exportPortlet(
				exportPermissions = "true",
				larFileName = "DM.portlet.lar");
		}

		task ("And: Imports the LAR file to the new site") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "site-name");

			LAR.importPortlet(
				importPermissions = "true",
				larFileName = "DM.portlet.lar");
		}

		task ("Then: The permissions of Site member will be changed according to the imported LAR file on the new site") {
			Portlet.gotoPortletOptions(portletOption = "Home Folder Permissions");

			SelectFrameTop();

			IFrame.selectModalFrame();

			for (var permissionDefinitionKey : list "CONFIGURATION_PERMISSIONS_ADD_SHORTCUT_CHECKBOX,CONFIGURATION_PERMISSIONS_ADD_DOCUMENT_CHECKBOX,CONFIGURATION_PERMISSIONS_SUBSCRIBE_CHECKBOX,CONFIGURATION_PERMISSIONS_VIEW_CHECKBOX,CONFIGURATION_PERMISSIONS_ADD_FOLDER") {
				Role.viewPermissionPG(
					permissionDefinitionKey = "${permissionDefinitionKey}",
					permissionFlagged = "false",
					roleTitle = "Site Member");
			}
		}
	}

	@description = "This is a use case for LPS-97544 and LPS-90886. Verify is possible import a staged site with circular reference."
	@priority = "3"
	test ImportStagedSiteWithCircularReference {
		property portal.upstream = "true";

		task ("Given: User adds a new site with 2 pages then activates local staging") {
			JSONGroup.addGroup(groupName = "Site Name");

			JSONLayout.addPublicLayout(
				groupName = "Site Name",
				layoutName = "Page A");

			JSONLayout.addPublicLayout(
				groupName = "Site Name",
				layoutName = "Page B");

			JSONStaging.enableLocalStaging(groupName = "Site Name");
		}

		task ("And: Add a new web content structure with a field") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name-staging");

			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "Structure Description A",
				structureName = "Structure Name A");

			DataEngine.addField(
				fieldFieldLabel = "Link to Page",
				fieldName = "Link to Page");

			WebContentStructures.saveCP(structureName = "Structure Name A");
		}

		task ("And: Add WC template connected with the previously created structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name-staging");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "Structure Name A",
				templateDescription = "Template Description A",
				templateFieldNames = "Link to Page",
				templateName = "Template Name A");
		}

		task ("And: Add another WC structure with a field") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name-staging");

			NavItem.gotoStructures();

			WebContentStructures.addCP(
				structureDescription = "Structure Description B",
				structureName = "Structure Name B");

			DataEngine.addField(
				fieldFieldLabel = "Web Content",
				fieldName = "Web Content");

			WebContentStructures.saveCP(structureName = "Structure Name B");
		}

		task ("And: Add another WC template connected with the second structure") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name-staging");

			NavItem.gotoTemplates();

			WebContentTemplates.addCP(
				structureName = "Structure Name B",
				templateDescription = "Template Description B",
				templateFieldNames = "Web Content",
				templateName = "Template Name B");
		}

		task ("And: Add a WC based on the first structure and first template linked to the second page") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name-staging");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "Structure Name A");

			WebContent.addWithStructureCP(
				structureName = "Structure Name A",
				templateName = "Template Name A",
				webContentLinkToPage = "Page B",
				webContentTitle = "WC WebContent Title 1");

			PortletEntry.publish();
		}

		task ("And: Add a second WC based on the second structure and second template, with a reference to the first WC") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "site-name-staging");

			WebContentNavigator.gotoAddWithStructureCP(structureName = "Structure Name B");

			WebContent.addWithStructureCP(
				structureName = "Structure Name B",
				templateName = "Template Name B",
				webContentTitle = "WC WebContent Title 2",
				webContentWebContent = "WC WebContent Title 1");

			PortletEntry.publish();
		}

		task ("And: Add a WCD widget on the first page and select the first WC on it") {
			Navigator.gotoStagedSitePage(
				pageName = "Page A",
				siteName = "Site Name");

			Portlet.addPG(portletName = "Web Content Display");

			WebContentDisplayPortlet.selectWebContent(webContentTitle = "WC WebContent Title 1");
		}

		task ("And: Add a WCD widget on the second page and select the second WC on it") {
			Navigator.gotoStagedSitePage(
				pageName = "Page B",
				siteName = "Site Name");

			Portlet.addPG(portletName = "Web Content Display");

			WebContentDisplayPortlet.selectWebContent(webContentTitle = "WC WebContent Title 2");
		}

		task ("When: User publish staging then exports the live site") {
			Staging.openStagingAdmin(siteURLKey = "site-name-staging");

			Staging.publishCustomPublication(rangeAll = "true");

			Navigator.gotoSitePage(
				pageName = "Page A",
				siteName = "Site Name");

			WebContentDisplayPortlet.viewContent(
				displayText = "Link to Page",
				pageName = "Page B",
				webContentTitle = "WC WebContent Title 1");

			LAR.exportSiteCP(siteScopeName = "Site Name");

			var key_larFileName = "${larFileName}";
			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("Then: Verify that the import process is successful on a new site") {
			JSONGroup.deleteGroupByName(groupName = "Site Name");

			JSONGroup.addGroup(groupName = "Site Name B");

			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "Site Name B");
		}
	}

	@description = "This is a use case for LPS-94738. Verify is possible import a WCD after activate staging."
	@priority = "4"
	test ImportWCDReferenceAfterActivateStaging {
		property test.name.skip.portal.instance = "ExportImport#ImportWCDReferenceAfterActivateStaging";

		task ("Given: User adds a new site with a page then a WCD widget to it") {
			JSONGroup.addGroup(groupName = "Site Name A");

			JSONLayout.addPublicLayout(
				groupName = "Site Name A",
				layoutName = "Test Page");

			JSONLayout.addWidgetToPublicLayout(
				groupName = "Site Name A",
				layoutName = "Test Page",
				widgetName = "Web Content Display");
		}

		task ("And: Add a WC to the new site page then export the site") {
			Navigator.gotoSitePage(
				pageName = "Test Page",
				siteName = "Site Name A");

			WebContentDisplayPortlet.add(
				webContentContent = "WebContent Content",
				webContentTitle = "WebContent Title");

			WebContentDisplayPortlet.viewContent(
				webContentContent = "WebContent Content",
				webContentTitle = "WebContent Title");

			LAR.exportSiteCP(siteScopeName = "Site Name A");

			var key_larFileName = "${larFileName}";
			var larFileName = LAR.getLarFileName();

			LAR.downloadLar();
		}

		task ("When: User deletes the created site then creates another with local staging") {
			JSONGroup.deleteGroupByName(groupName = "Site Name A");

			JSONGroup.addGroup(groupName = "Site Name B");

			JSONStaging.enableLocalStaging(groupName = "Site Name B");
		}

		task ("And: Imports the previously exported site's LAR file") {
			LAR.importSiteCP(
				larFileName = "${larFileName}",
				siteName = "site-name-b-staging");
		}

		task ("Then: The WC will be visible on the page of the new site") {
			Navigator.gotoStagedSitePage(
				pageName = "Test Page",
				siteName = "Site Name B");

			WebContentDisplayPortlet.viewContent(
				webContentContent = "WebContent Content",
				webContentTitle = "WebContent Title");
		}
	}

	@description = "This is a use case for LPS-91233. Verify is possible publish a web content with a broken link."
	@priority = "3"
	test PublishWebContentWithBrokenLink {
		property test.name.skip.portal.instance = "ExportImport#PublishWebContentWithBrokenLink";

		task ("Given: User disable the validation of file entries and layout references") {
			ApplicationsMenu.gotoPortlet(
				category = "Configuration",
				panel = "Control Panel",
				portlet = "System Settings");

			SystemSettings.gotoConfiguration(
				configurationCategory = "Infrastructure",
				configurationName = "Export/Import, Staging",
				configurationScope = "Virtual Instance Scope");

			SystemSettings.configureSystemSetting(
				enableSetting = "false",
				settingFieldName = "Validate File Entries");

			SystemSettings.configureSystemSetting(
				enableSetting = "false",
				settingFieldName = "Validate Layout References");
		}

		task ("When: User adds a new document and save the document's external URL") {
			DMNavigator.openDocumentsAndMediaAdmin(siteURLKey = "guest");

			DMDocument.addCP(
				dmDocumentDescription = "DM Document Description",
				dmDocumentFile = "Document_1.jpg",
				dmDocumentTitle = "DM Document Title");

			DMNavigator.gotoDocumentCP(dmDocumentTitle = "DM Document Title");

			DMDocument.expandInfo();

			var dmDocumentURL = selenium.getAttribute("//input[contains(@id,'urlInput')]@value");

			var entryExternalURL = StringUtil.replace("${dmDocumentURL}", "http://", "");
		}

		task ("And: Delete the newly created file") {
			JSONDocument.deleteFile(
				dmDocumentTitle = "DM Document Title",
				groupName = "Guest");
		}

		task ("Then: User can create a new WC with the saved external link of the deleted document") {
			WebContentNavigator.openWebContentAdmin(siteURLKey = "guest");

			WebContentNavigator.gotoAddCP();

			PortletEntry.inputTitle(title = "WC WebContent Title");

			CKEditor.addEntryExternalURL(
				displayText = "${dmDocumentURL}",
				entryExternalURL = "${entryExternalURL}",
				fieldLabel = "Content");

			PortletEntry.publish();
		}
	}

}